{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Practicing MicroProfile with Helidon Open the guided exercises","title":"Practicing MicroProfile with Helidon"},{"location":"#practicing-microprofile-with-helidon","text":"Open the guided exercises","title":"Practicing MicroProfile with Helidon"},{"location":"guided_exercises/00_environment/","text":"Environment Prerequisites Maven CLI; Git CLI; Java 11; An IDE of your preference; If using Windows, PowerShell is recommended; Helidon CLI (optional) ; REST client tools like cURL or postman (Optional) ; Info The helidon CLI is needed for only on optional labs where you can experience some features that are only available through this tool. To check if you have the above tools installed, open your terminal and running the following the commands. You should be able to see the version of each of the tools: java -version mvn -version git --version Installing helidon CLI (optional) To install Helidon, you can run the commands below according to your O.S: MacOS: curl -O https://helidon.io/cli/2.3.3/darwin/helidon chmod +x ./helidon sudo mv ./helidon /usr/local/bin/ Linux: curl -O https://helidon.io/cli/2.3.3/linux/helidon chmod +x ./helidon sudo mv ./helidon /usr/local/bin/ Windows: PowerShell -Command Invoke-WebRequest -Uri \"https://helidon.io/cli/2.3.3/windows/helidon.exe\" -OutFile \"C:\\Windows\\system32\\helidon.exe\" You can verify the installation by running in the terminal: helidon version Helidon CLI is available for Helidon 2+. Prepare your working directory The exercises are built on top of quickstart projects, a foundation of preconfigured projects. You need the projects available in your local development environment. To get the foundation projects and build them, you can run: git clone https://github.com/architects4j/helidon-microstream-training-labs-foundation cd helidon-microstream-training-labs-foundation mvn clean package The build and packaging should complete successfully.","title":"Environment"},{"location":"guided_exercises/00_environment/#environment","text":"","title":"Environment"},{"location":"guided_exercises/00_environment/#prerequisites","text":"Maven CLI; Git CLI; Java 11; An IDE of your preference; If using Windows, PowerShell is recommended; Helidon CLI (optional) ; REST client tools like cURL or postman (Optional) ; Info The helidon CLI is needed for only on optional labs where you can experience some features that are only available through this tool. To check if you have the above tools installed, open your terminal and running the following the commands. You should be able to see the version of each of the tools: java -version mvn -version git --version","title":"Prerequisites"},{"location":"guided_exercises/00_environment/#installing-helidon-cli-optional","text":"To install Helidon, you can run the commands below according to your O.S: MacOS: curl -O https://helidon.io/cli/2.3.3/darwin/helidon chmod +x ./helidon sudo mv ./helidon /usr/local/bin/ Linux: curl -O https://helidon.io/cli/2.3.3/linux/helidon chmod +x ./helidon sudo mv ./helidon /usr/local/bin/ Windows: PowerShell -Command Invoke-WebRequest -Uri \"https://helidon.io/cli/2.3.3/windows/helidon.exe\" -OutFile \"C:\\Windows\\system32\\helidon.exe\" You can verify the installation by running in the terminal: helidon version Helidon CLI is available for Helidon 2+.","title":"Installing helidon CLI (optional)"},{"location":"guided_exercises/00_environment/#prepare-your-working-directory","text":"The exercises are built on top of quickstart projects, a foundation of preconfigured projects. You need the projects available in your local development environment. To get the foundation projects and build them, you can run: git clone https://github.com/architects4j/helidon-microstream-training-labs-foundation cd helidon-microstream-training-labs-foundation mvn clean package The build and packaging should complete successfully.","title":"Prepare your working directory"},{"location":"guided_exercises/01_helidon_getting_started/","text":"Getting started with Helidon Introduction What you will learn Here are the key learnings you will get with this hands-on execise: Learn how to use the microprofile starter to generate your first Microprofile application, using Helidon as the runtime; Explore the basic structure of a Helidon project; Learn how to use Helidon CLI; Check the experience of the Dev Loop with Helidon CLI. Pre requisites To be able to go through this guided exercise, you will need to have the following components in your dev environment: Have finished the steps described in Preparing your environment Hands-on practice Creating a new project Let's create a new project using MP Starter page. Access the page https://start.microprofile.io/ . Use the following the data and click on download. You will get a zip file with an automatically generated project for you to get started. Method Description groupId org.a4j artifactId hello-helidon MicroProfile Version 3.3 Build Tool Maven MicroProfile Runtime Helidon Unzip the file hello-helidon.zip . You should have a project structure like this: . \u251c\u2500\u2500 pom.xml \u251c\u2500\u2500 readme.md \u2514\u2500\u2500 src \u2514\u2500\u2500 main \u251c\u2500\u2500 java \u2502 \u2514\u2500\u2500 org \u2502 \u2514\u2500\u2500 a4j \u2502 \u2514\u2500\u2500 hello \u2502 \u2514\u2500\u2500 helidon \u2502 \u251c\u2500\u2500 HelloController.java \u2502 \u2514\u2500\u2500 HellohelidonRestApplication.java \u2514\u2500\u2500 resources \u251c\u2500\u2500 META-INF \u2502 \u251c\u2500\u2500 beans.xml \u2502 \u2514\u2500\u2500 microprofile-config.properties \u251c\u2500\u2500 WEB \u2502 \u2514\u2500\u2500 index.html \u251c\u2500\u2500 logging.properties \u2514\u2500\u2500 privateKey.pem Explore the classes and check what is available out of the box, when we don't select any extra features in the starter page. Running the project Open the terminal and access the project's folder. Run the following maven command. Maven will download the dependencies described in the project's pom.xml file. It will also create an executable jar we can use to access our application: hello-payara-microbundle.jar . mvn clean package Now, let's start our first Helidon service. In the terminal, run the following command: java -jar target/hello-helidon.jar If everything goes well, you should see an output similar to: INFO io.helidon.microprofile.server.ServerCdiExtension !thread!: Server started on http://localhost:8080 (and all other host addresses) in 2319 milliseconds (since JVM startup). INFO io.helidon.common.HelidonFeatures !thread!: Helidon MP 2.4.1 features: [CDI, Config, Fault Tolerance, Health, JAX-RS, Metrics, Open API, REST Client, Security, Server, Tracing] In your browser, access the page http://localhost:8080/data/hello What are the classes that are responding to this request? Now change the message that is displayed in this page. Package your application, start it again, and check the changes on the page. Congratulations You've successfully created, packaged, changed and accessed an application based on the MicroProfile specification and that runs with the Helidon runtime! Using Helidon CLI [Optional] You can use Helidon CLI for executing tasks like creating new projects and using a feature called \"Developer Loop\". The Developer Loop allows you to leverage hot reload features while coding your helidon services. Using a terminal, access your project's folder hello-helidon . Run the app using the dev loop with: helidon dev After the tool finishes downloading the artifacts, you should be able to see something like: | downloading artifacts | building | build completed ( 1 .9 seconds ) | hello-helidon starting ... 2022 .05.27 22 :59:32 INFO io.helidon.common.HelidonFeatures !thread!: Helidon MP 2 .4.1 features: [ CDI, Config, Fault Tolerance, Health, JAX-RS, Metrics, Open API, REST Client, Security, Server, Tracing ] Alert Sometimes the dev loop might not work on the first initialization of helidon dev. To avoid issues, you can stop the service with ctrl+c (or cmd+c) and start it again with helidon dev . Open the service in your browser: http://localhost:8080/data/hello On your IDE, open the class org.a4j.hello.helidon.HelloController Change the endpoint path to devloop and the string returned by the method sayHello to \"Hello Dev Loop!\" Back in your browser, check your changes reflected at http://localhost:8080/data/devloop Additional information When you are you GraalVM, you can compile your helidon services using Ahead of Time compilation. AoT is a strategy to have the compilation processing during build time, allowing you to create native executable files with fast startup time. For more information check the Helidon docs for Helidon SE GraalVM native image .","title":"Getting started with Helidon"},{"location":"guided_exercises/01_helidon_getting_started/#getting-started-with-helidon","text":"","title":"Getting started with Helidon"},{"location":"guided_exercises/01_helidon_getting_started/#introduction","text":"","title":"Introduction"},{"location":"guided_exercises/01_helidon_getting_started/#what-you-will-learn","text":"Here are the key learnings you will get with this hands-on execise: Learn how to use the microprofile starter to generate your first Microprofile application, using Helidon as the runtime; Explore the basic structure of a Helidon project; Learn how to use Helidon CLI; Check the experience of the Dev Loop with Helidon CLI.","title":"What you will learn"},{"location":"guided_exercises/01_helidon_getting_started/#pre-requisites","text":"To be able to go through this guided exercise, you will need to have the following components in your dev environment: Have finished the steps described in Preparing your environment","title":"Pre requisites"},{"location":"guided_exercises/01_helidon_getting_started/#hands-on-practice","text":"","title":"Hands-on practice"},{"location":"guided_exercises/01_helidon_getting_started/#creating-a-new-project","text":"Let's create a new project using MP Starter page. Access the page https://start.microprofile.io/ . Use the following the data and click on download. You will get a zip file with an automatically generated project for you to get started. Method Description groupId org.a4j artifactId hello-helidon MicroProfile Version 3.3 Build Tool Maven MicroProfile Runtime Helidon Unzip the file hello-helidon.zip . You should have a project structure like this: . \u251c\u2500\u2500 pom.xml \u251c\u2500\u2500 readme.md \u2514\u2500\u2500 src \u2514\u2500\u2500 main \u251c\u2500\u2500 java \u2502 \u2514\u2500\u2500 org \u2502 \u2514\u2500\u2500 a4j \u2502 \u2514\u2500\u2500 hello \u2502 \u2514\u2500\u2500 helidon \u2502 \u251c\u2500\u2500 HelloController.java \u2502 \u2514\u2500\u2500 HellohelidonRestApplication.java \u2514\u2500\u2500 resources \u251c\u2500\u2500 META-INF \u2502 \u251c\u2500\u2500 beans.xml \u2502 \u2514\u2500\u2500 microprofile-config.properties \u251c\u2500\u2500 WEB \u2502 \u2514\u2500\u2500 index.html \u251c\u2500\u2500 logging.properties \u2514\u2500\u2500 privateKey.pem Explore the classes and check what is available out of the box, when we don't select any extra features in the starter page.","title":"Creating a new project"},{"location":"guided_exercises/01_helidon_getting_started/#running-the-project","text":"Open the terminal and access the project's folder. Run the following maven command. Maven will download the dependencies described in the project's pom.xml file. It will also create an executable jar we can use to access our application: hello-payara-microbundle.jar . mvn clean package Now, let's start our first Helidon service. In the terminal, run the following command: java -jar target/hello-helidon.jar If everything goes well, you should see an output similar to: INFO io.helidon.microprofile.server.ServerCdiExtension !thread!: Server started on http://localhost:8080 (and all other host addresses) in 2319 milliseconds (since JVM startup). INFO io.helidon.common.HelidonFeatures !thread!: Helidon MP 2.4.1 features: [CDI, Config, Fault Tolerance, Health, JAX-RS, Metrics, Open API, REST Client, Security, Server, Tracing] In your browser, access the page http://localhost:8080/data/hello What are the classes that are responding to this request? Now change the message that is displayed in this page. Package your application, start it again, and check the changes on the page. Congratulations You've successfully created, packaged, changed and accessed an application based on the MicroProfile specification and that runs with the Helidon runtime!","title":"Running the project"},{"location":"guided_exercises/01_helidon_getting_started/#using-helidon-cli-optional","text":"You can use Helidon CLI for executing tasks like creating new projects and using a feature called \"Developer Loop\". The Developer Loop allows you to leverage hot reload features while coding your helidon services. Using a terminal, access your project's folder hello-helidon . Run the app using the dev loop with: helidon dev After the tool finishes downloading the artifacts, you should be able to see something like: | downloading artifacts | building | build completed ( 1 .9 seconds ) | hello-helidon starting ... 2022 .05.27 22 :59:32 INFO io.helidon.common.HelidonFeatures !thread!: Helidon MP 2 .4.1 features: [ CDI, Config, Fault Tolerance, Health, JAX-RS, Metrics, Open API, REST Client, Security, Server, Tracing ] Alert Sometimes the dev loop might not work on the first initialization of helidon dev. To avoid issues, you can stop the service with ctrl+c (or cmd+c) and start it again with helidon dev . Open the service in your browser: http://localhost:8080/data/hello On your IDE, open the class org.a4j.hello.helidon.HelloController Change the endpoint path to devloop and the string returned by the method sayHello to \"Hello Dev Loop!\" Back in your browser, check your changes reflected at http://localhost:8080/data/devloop","title":"Using Helidon CLI [Optional]"},{"location":"guided_exercises/01_helidon_getting_started/#additional-information","text":"When you are you GraalVM, you can compile your helidon services using Ahead of Time compilation. AoT is a strategy to have the compilation processing during build time, allowing you to create native executable files with fast startup time. For more information check the Helidon docs for Helidon SE GraalVM native image .","title":"Additional information"},{"location":"guided_exercises/02_cdi_lab/","text":"Contexts and Dependency Injection (CDI) Introduction What you will learn Here are the main goals you will achieve with this hands-on execise: Learn how to use the reference implementation of the CDI specification, Weld . Learn how to get access to the current container in Java SE applications using an important class in the CDI world, javax.enterprise.inject.se.SeContainer . Try out different scopes and test the injection of different objects and their behavior; Practice the concept of observers and event listeners; CDI overview Contexts and Depedendency Injection (CDI) is an specification included in Java since version 6. It brings loose coupling between components of the application and makes it easy for developers to manage stateful object instances and connect together different layers of the application. When getting started with CDI, there are key concepts developers be aware of: Beans Dependency Injection Qualifiers Scopes Interceptors Events. Info For detailed explanation and examples refer to the CDI's user guides . The fundamental concept to learn is the managed bean . According the the CDIn's user guides : \"(...) Managed Beans are defined as container-managed objects with minimal programming restrictions, otherwise known by the acronym POJO (Plain Old Java Object). They support a small set of basic services, such as resource injection, lifecycle callbacks and interceptors. (...)\" . With CDI developers have the possibility to manage stateful components' lifecycle. There are in total five different scopes that can be used, being @Dependent , @Conversation , @RequestScoped and @ApplicationScoped . See below explanation for the default option, and other two commonly used options: The Default Scope This is the default scope for managed beans in case none is configured. Managed Beans with default scope last the same time as its client bean. The request scope Managed beans configured with @RequestScoped will last for an HTTP request lifespan, say, in a web application. The application scope : Managed beans configured with @ApplicationScoped will exist throughout all interactions done with an application, including different users' interaction and requests. Tip For more information about application scopes, please refer to Weld - reference implementation of CDI - User Guide: Weld: Scopes and Contexts and the Jakarta EE CDI 3.0 Specification Document . Pre requisites To be able to go through this guided exercise, you will need to have the following components in your dev environment: Have finished the steps described in Preparing your environment Hands-on practice Let's get started with the exercise with a series of steps that will guide you through completing the implementation of a project. First steps Inside the cloned repository helidon-microstream-training-labs-foundation , you'll find the project cdi-lab . Open the project cdi-lab in your IDE of choice. Open the pom.xml file. In the <dependencies> section, line 21, add the dependency to Weld. Weld is reference implementation of the CDI specification. <dependency> <groupId> org.jboss.weld.se </groupId> <artifactId> weld-se-shaded </artifactId> <version> ${weld.se.core.version} </version> </dependency> Notice the version is already configured in pom.xml , in the property weld.se.core.version . Build and install the application using maven command line or your IDE: mvn clean install Your project isn't going to compile yet, due to other unfinished code. Let's move on to the next step. Contexts and objects behaviors Now, let's start practicing with the Vehicle example demonstrated by the instructor. You will finish the project implementation, run it and analise it yourself. Using your IDE of choice, open the Class App1.java . In the next steps, we'll update this class where: a new container should be created, and we will use it to inject an instance of an object that inherits the Interface Vehicle and an instance of an object based on the class Car . Instantiating an SeContainer Locate in the App1.java the line 15. try ( SeContainer container = null ) { This code is incorrect, since container should not be initializated with null. To fix this code, replace the \"null\" initialization with an intialization done with the class SeContainerInitializer . Tip To use the initialize() method, you should first create a newInstance() if the SeContainerInitializer . To make sure the project is compiling, you can run mvn clean install without errors. Tip If you try to run the main method in the class App1 you will get a RuntimeException, NullPointerException because there is still code that needs to be initialized correctly. Also, if your project was generated with microprofile starter or helidon maven archetype, you might get an IllegalStateException if you try to run the main method. That is due to the io.helidon.microprofile.cdi implementation that is being used. If you use it instead of weld, in order to be able to execute the main method, you need to add the property configuration mp.initializer.allow=true to your microprofile-config.properties . Obtaining existing object instances in the SeContainer In the class App1 , locate the object car initialization on line 23. Car car = null ; car . move (); An object car may already exist in the container. If so, there is no need to create a new instance of this class. Use the container to obtain the existing car instance (if existing). The great thing about the CDI API is that by default, if no object instance is located in memory, it creates a new instance and retrieves it. Tip Check how the Vehicle is being obtained from the container. Be sure to obtain an instance of the Car class, and not the interface Vehicle . Make sure the project is compiling, run mvn clean install without errors. Testing your code: Now, execute the main method of the class App1 . Confirm you see a message output in the logs like: \"Is the same vehicle? true\" In this code, we use CDI to obtain an instance of a Vehicle and then, of a Car. Why does the CDI API return the same object? Checking the CDI Scope Open the class Car . Locate the declaration of this bean's scope, on line 8: @ApplicationScoped public class Car implements Vehicle { Comment the annotation @ApplicationScoped and save the file. The class should look like: // @ApplicationScoped public class Car implements Vehicle { Now, run your code again and check the output. Did you get a different output message? Why changing the scope of the Car bean changed the behavior of our code? Producers and Consumers When working with Java code, we can leverage the CDI API to create classes that will behave and producers and consumers. In other words, instead of invoking a behavior of a specific class, we can instead create decoupled code that reacts to specific events in the container. Let's see this in action by trying out the news example demonstrated by the instructor. Open the project cdi-lab in your IDE of choice if you still haven't. In this project we have the package my.compary.cdi.lab.news with the classes: Journalist class that is a producer responsible for notifying the news to every consumer in the project; There are three consumers in this project: Magazine , Newspaper , and SocialMedia . Open the Journalist.java class, and: Analyse the different CDI annotations, like @ApplicationScoped and @Inject . What is this \"Event\" class and what can you use it for? On the line 14, inside the method receiveNews , fire events containing the news, using the injected object event . Open the Magazine , Newspaper , and SocialMedia classes. Notice it implements the interface java.util.function.Consumer . Fix the method accept , by making it react to events that were fired in this application scope. Tip You may want to use the anotation @javax.enterprise.event.Observes ; Finally, open the class App4.java and analyse it. Validate if you did everything right by running the main method in App4 . You should see in a log output for each observer (three in total), containing messages like: \"We got the news, we'll publish it on Social Media: Java 17 has arrived!!\". INFO: WELD-ENV-002003: Weld SE container 724cb2e4-edb7-4de5-8b0f-df2adc814bb3 initialized Oct 10 , 2021 8 :52:36 PM my.compary.cdi.lab.news.SocialMedia accept INFO: We got the news, we 'll publish it on Social Media: Java 17 has arrived!! Oct 10, 2021 8:52:36 PM my.compary.cdi.lab.news.NewsPaper accept INFO: We got the news, we' ll publish it on a newspaper: Java 17 has arrived!! Oct 10 , 2021 8 :52:36 PM my.compary.cdi.lab.news.Magazine accept INFO: We got the news, we ' ll publish it on a magazine: Java 17 has arrived!! Oct 10 , 2021 8 :52:36 PM org.jboss.weld.environment.se.WeldContainer shutdown INFO: WELD-ENV-002001: Weld SE container 724cb2e4-edb7-4de5-8b0f-df2adc814bb3 shut down Why these messages were logged, if we never invoked the method accept in those classes (e.g. magazine.accept(news) )? Congratulations You've successfully completed the CDI exercise.There are several ways to use CDI in Java applications. In these exercises you could practice some of the features that can be leverage in application where you can use CDI. You also configured and used the specification through Weld, the reference implementation of the specification, but there are several others where each vendor provides their own implementation of the CDI spec.","title":"Contexts and Dependency Injection (CDI)"},{"location":"guided_exercises/02_cdi_lab/#contexts-and-dependency-injection-cdi","text":"","title":"Contexts and Dependency Injection (CDI)"},{"location":"guided_exercises/02_cdi_lab/#introduction","text":"","title":"Introduction"},{"location":"guided_exercises/02_cdi_lab/#what-you-will-learn","text":"Here are the main goals you will achieve with this hands-on execise: Learn how to use the reference implementation of the CDI specification, Weld . Learn how to get access to the current container in Java SE applications using an important class in the CDI world, javax.enterprise.inject.se.SeContainer . Try out different scopes and test the injection of different objects and their behavior; Practice the concept of observers and event listeners;","title":"What you will learn"},{"location":"guided_exercises/02_cdi_lab/#cdi-overview","text":"Contexts and Depedendency Injection (CDI) is an specification included in Java since version 6. It brings loose coupling between components of the application and makes it easy for developers to manage stateful object instances and connect together different layers of the application. When getting started with CDI, there are key concepts developers be aware of: Beans Dependency Injection Qualifiers Scopes Interceptors Events. Info For detailed explanation and examples refer to the CDI's user guides . The fundamental concept to learn is the managed bean . According the the CDIn's user guides : \"(...) Managed Beans are defined as container-managed objects with minimal programming restrictions, otherwise known by the acronym POJO (Plain Old Java Object). They support a small set of basic services, such as resource injection, lifecycle callbacks and interceptors. (...)\" . With CDI developers have the possibility to manage stateful components' lifecycle. There are in total five different scopes that can be used, being @Dependent , @Conversation , @RequestScoped and @ApplicationScoped . See below explanation for the default option, and other two commonly used options: The Default Scope This is the default scope for managed beans in case none is configured. Managed Beans with default scope last the same time as its client bean. The request scope Managed beans configured with @RequestScoped will last for an HTTP request lifespan, say, in a web application. The application scope : Managed beans configured with @ApplicationScoped will exist throughout all interactions done with an application, including different users' interaction and requests. Tip For more information about application scopes, please refer to Weld - reference implementation of CDI - User Guide: Weld: Scopes and Contexts and the Jakarta EE CDI 3.0 Specification Document .","title":"CDI overview"},{"location":"guided_exercises/02_cdi_lab/#pre-requisites","text":"To be able to go through this guided exercise, you will need to have the following components in your dev environment: Have finished the steps described in Preparing your environment","title":"Pre requisites"},{"location":"guided_exercises/02_cdi_lab/#hands-on-practice","text":"Let's get started with the exercise with a series of steps that will guide you through completing the implementation of a project.","title":"Hands-on practice"},{"location":"guided_exercises/02_cdi_lab/#first-steps","text":"Inside the cloned repository helidon-microstream-training-labs-foundation , you'll find the project cdi-lab . Open the project cdi-lab in your IDE of choice. Open the pom.xml file. In the <dependencies> section, line 21, add the dependency to Weld. Weld is reference implementation of the CDI specification. <dependency> <groupId> org.jboss.weld.se </groupId> <artifactId> weld-se-shaded </artifactId> <version> ${weld.se.core.version} </version> </dependency> Notice the version is already configured in pom.xml , in the property weld.se.core.version . Build and install the application using maven command line or your IDE: mvn clean install Your project isn't going to compile yet, due to other unfinished code. Let's move on to the next step.","title":"First steps"},{"location":"guided_exercises/02_cdi_lab/#contexts-and-objects-behaviors","text":"Now, let's start practicing with the Vehicle example demonstrated by the instructor. You will finish the project implementation, run it and analise it yourself. Using your IDE of choice, open the Class App1.java . In the next steps, we'll update this class where: a new container should be created, and we will use it to inject an instance of an object that inherits the Interface Vehicle and an instance of an object based on the class Car .","title":"Contexts and objects behaviors"},{"location":"guided_exercises/02_cdi_lab/#instantiating-an-secontainer","text":"Locate in the App1.java the line 15. try ( SeContainer container = null ) { This code is incorrect, since container should not be initializated with null. To fix this code, replace the \"null\" initialization with an intialization done with the class SeContainerInitializer . Tip To use the initialize() method, you should first create a newInstance() if the SeContainerInitializer . To make sure the project is compiling, you can run mvn clean install without errors. Tip If you try to run the main method in the class App1 you will get a RuntimeException, NullPointerException because there is still code that needs to be initialized correctly. Also, if your project was generated with microprofile starter or helidon maven archetype, you might get an IllegalStateException if you try to run the main method. That is due to the io.helidon.microprofile.cdi implementation that is being used. If you use it instead of weld, in order to be able to execute the main method, you need to add the property configuration mp.initializer.allow=true to your microprofile-config.properties .","title":"Instantiating an SeContainer"},{"location":"guided_exercises/02_cdi_lab/#obtaining-existing-object-instances-in-the-secontainer","text":"In the class App1 , locate the object car initialization on line 23. Car car = null ; car . move (); An object car may already exist in the container. If so, there is no need to create a new instance of this class. Use the container to obtain the existing car instance (if existing). The great thing about the CDI API is that by default, if no object instance is located in memory, it creates a new instance and retrieves it. Tip Check how the Vehicle is being obtained from the container. Be sure to obtain an instance of the Car class, and not the interface Vehicle . Make sure the project is compiling, run mvn clean install without errors.","title":"Obtaining existing object instances in the SeContainer"},{"location":"guided_exercises/02_cdi_lab/#testing-your-code","text":"Now, execute the main method of the class App1 . Confirm you see a message output in the logs like: \"Is the same vehicle? true\" In this code, we use CDI to obtain an instance of a Vehicle and then, of a Car. Why does the CDI API return the same object? Checking the CDI Scope Open the class Car . Locate the declaration of this bean's scope, on line 8: @ApplicationScoped public class Car implements Vehicle { Comment the annotation @ApplicationScoped and save the file. The class should look like: // @ApplicationScoped public class Car implements Vehicle { Now, run your code again and check the output. Did you get a different output message? Why changing the scope of the Car bean changed the behavior of our code?","title":"Testing your code:"},{"location":"guided_exercises/02_cdi_lab/#producers-and-consumers","text":"When working with Java code, we can leverage the CDI API to create classes that will behave and producers and consumers. In other words, instead of invoking a behavior of a specific class, we can instead create decoupled code that reacts to specific events in the container. Let's see this in action by trying out the news example demonstrated by the instructor. Open the project cdi-lab in your IDE of choice if you still haven't. In this project we have the package my.compary.cdi.lab.news with the classes: Journalist class that is a producer responsible for notifying the news to every consumer in the project; There are three consumers in this project: Magazine , Newspaper , and SocialMedia . Open the Journalist.java class, and: Analyse the different CDI annotations, like @ApplicationScoped and @Inject . What is this \"Event\" class and what can you use it for? On the line 14, inside the method receiveNews , fire events containing the news, using the injected object event . Open the Magazine , Newspaper , and SocialMedia classes. Notice it implements the interface java.util.function.Consumer . Fix the method accept , by making it react to events that were fired in this application scope. Tip You may want to use the anotation @javax.enterprise.event.Observes ; Finally, open the class App4.java and analyse it. Validate if you did everything right by running the main method in App4 . You should see in a log output for each observer (three in total), containing messages like: \"We got the news, we'll publish it on Social Media: Java 17 has arrived!!\". INFO: WELD-ENV-002003: Weld SE container 724cb2e4-edb7-4de5-8b0f-df2adc814bb3 initialized Oct 10 , 2021 8 :52:36 PM my.compary.cdi.lab.news.SocialMedia accept INFO: We got the news, we 'll publish it on Social Media: Java 17 has arrived!! Oct 10, 2021 8:52:36 PM my.compary.cdi.lab.news.NewsPaper accept INFO: We got the news, we' ll publish it on a newspaper: Java 17 has arrived!! Oct 10 , 2021 8 :52:36 PM my.compary.cdi.lab.news.Magazine accept INFO: We got the news, we ' ll publish it on a magazine: Java 17 has arrived!! Oct 10 , 2021 8 :52:36 PM org.jboss.weld.environment.se.WeldContainer shutdown INFO: WELD-ENV-002001: Weld SE container 724cb2e4-edb7-4de5-8b0f-df2adc814bb3 shut down Why these messages were logged, if we never invoked the method accept in those classes (e.g. magazine.accept(news) )? Congratulations You've successfully completed the CDI exercise.There are several ways to use CDI in Java applications. In these exercises you could practice some of the features that can be leverage in application where you can use CDI. You also configured and used the specification through Weld, the reference implementation of the specification, but there are several others where each vendor provides their own implementation of the CDI spec.","title":"Producers and Consumers"},{"location":"guided_exercises/03_rest_client_lab/","text":"Creating a client service with MicroProfile RestClient Introduction What you will learn Here are the main goals you will achieve with this hands-on execise: Learn the configuration required in a Helidon service to allow it to consume an external endpoints. With JAX-RS service, execute five different operations through an external service: List all Find by ID Insert Update Delete Use Case For this scenario, you will use an existing JAX-RS service, the restaurant service . You will create a client application that can consume all the RESTful APIs available in the restaurant service . You will start with an existing service with a foundation that will support the development of your client application. Your task is to finish the service, as all the RestClient configuration and implementation is missing.Make sure your service can properly interact with the restaurant service . Pre requisites To be able to go through this guided exercise, you will need to have the following components in your dev environment: Have finished the steps described in Preparing your environment Hands-on practice For this scenario, you should create a client service that consumes an existing JAX-RS service: the restaurant service . You will enhance a partially written restaurant client service to allow it to integrate with the following restaurant service APIs: Method Path Description GET /restaurants Fetch all the items GET /restaurants/{id} Fetch an item by ID POST /restaurants Insert new items PUT /restaurants/{id} Update items DELETE /restaurants/{id} Delete items The client service is partially written and you are the one responsible for creating all the RestClient configuration and implementation that are missing. Your task is to finish this application and make sure you can interact with the restaurant service . Understanding the services The restaurant service The restaurant service provides RESTful APIs that allow managing the items that are currently needed by the restaurant. An item has the following structure: { \"name\" : \"water\" , \"description\" : \"Water appears as a clear, nontoxic liquid composed of hydrogen and oxygen, essential for life.\" , \"type\" : \"BEVERAGE\" , \"expires\" : \"2025-12-03\" , \"ingredients\" : [{ \"name\" : \"water\" , \"unit\" : \"L\" , \"quantity\" : 2 }] } Since our application needs to integrate with this service, after the implementation is finished, a practical test will require both services to be up running in our environment. In the restaurant service , check the class RestaurantController . These are the endpoints your client service should consume. Next, let's check the existing code for the client service and start coding. The restaurant client service Locate and open with your IDE of choice the project helidon-microstream-training-labs-foundation/restaurant-client-lab . Open the pom.xml and check your project has the following dependency: <dependency> <groupId> org.microprofile-ext.openapi-ext </groupId> <artifactId> openapi-ui </artifactId> <version> 1.1.5 </version> </dependency> This is the MP OpenAPI-UI extension . It will allow you to use your browser to interact with the REST APIs you are about to create. Once you are finished, you will see something like this: Let's get started with the integration of our restaurant client service and the restaurant service using MicroProfile RESTClient. Integrating through MicroProfile RESTClient In order to consume a service using RESTClient, we will: Create an interface that will match the service operations we want to be able to invoke; Set up the appropriate annotations to configure this interface as a rest client; Add to the application properties a reference to the external service that will be consumed by the rest client; Creating the RESTClient interface Open the restaurant-client-lab in your IDE. Locate and open the RestaurantService interface. This is the interface we'll use as a RestClient to consume the external API exposed by Restaurant Controller part of the restaurant-service . Configure this interface as a RESTClient by adding, before the interface's name, the annotations @Path(\"restaurants\") and @RegisterRestClient . It will look like this: @Path ( \"restaurants\" ) @RegisterRestClient public interface RestaurantService { The next step is to create the contract of the methods you will consume on the external service. As a first example, let's check the insert operation. The RestaurantController (part of the restaurant-service ) , has the following method: @POST public Response insert ( @Valid Item item ) { return Response . status ( Response . Status . CREATED ) . entity ( repository . save ( item )) . build (); } In order to invoke the endpoint exposed by this method, create the following method declaration in your RestaurantService Interface : @POST public Response insert ( Item item ); Awesome! You've just created the first integration between your client and the external service! It's as easy as that! Now, implement the other four method declarations in the RestaurantService interface. Make sure you have all five methods of the external service: findById , insert , update , delete and getAll . Configuring the RestaurantService endpoint The next step is to create a MicroProfile configuration property, where the property's name is the RESTClient interface FQDN, and the value is the external service URL. Add the following property in resources/META-INF/microprofile-config.properties : org.a4j.restaurant.client.RestaurantService/mp-rest/url = http://localhost:8080/ Good job The client configuration is now done. You've learned that when using RESTClient, the integration is done with really few code. The contract goes within the interface and all configuration within the microprofile-config.properties file. Testing the service To test this service you need to run two applications, the restaurant-service and the restaurant-client-service . Each service will run in a different port. Starting the restaurant service To start the restaurant service locally, follow these steps: Open the terminal; Access the foundation project directory, e.g.: cd $YOUR_CUSTOM_DIR /helidon-microstream-training-labs-foundation/restaurant Package and run the service: mvn clean package java -jar target/restaurant.jar Use your browser to confirm the service is up and running at: Restaurant service: http://localhost:8080/ About the restaurant service persistence For this lab's learning purpose a database persistence is not required. The service uses an in-memory list to store and retrieve data. To simplify the lab it is also initialized with two items in the list : \"Water\" and \"Juice\". Now, let's package and run our client. Starting the restaurant client service On a different terminal tab, access the service directory. e.g. cd $YOUR_CUSTOM_DIR /helidon-microstream-training-labs-foundation/restaurant-client-lab Package and run the service: mvn clean package pom.xml java -jar target/restaurant-client-lab.jar Use your browser to confirm the service is up and running at Restaurant client service: http://localhost:8081/ Testing the restaurant client service Your client includes the microprofile extension ui for OpenAPI. To access the ui, open: Client OpenAPI UI: http://localhost:8081/openapi-ui . Select the GET /items endpoint, click on \" try it out \" button, and then on the \" Execute \" blue button. You should get an HTTP 200 response and a list with two items. Now, use your client service API to delete the \" juice \" item. In your browser, locate the DELETE items endpoint and click on \"Try it out\" . Type juice in the Id field and click on the Execute button. Finally, confirm that the item was deleted and is not retrieved with the GET items endpoint endpoint. The response should be an HTTP 200 and juice should not be in the list. [ { \"description\" : \"Water appears as a clear, nontoxic liquid composed of hydrogen and oxygen, essential for life\" , \"expires\" : \"2025-05-29\" , \"ingredients\" : [ { \"name\" : \"water\" , \"quantity\" : 2 , \"unit\" : \"L\" } ], \"name\" : \"water\" , \"type\" : \"BEVERAGE\" } ] Feel free to use the OpenAPI UI, postman or cURL to test all your service's endpoints. Congratulations Congratulations, you've implemented a client service application with Helidon and Microprofile that can consume an external JAX-RS service by using the new RESTClient MicroProfile!","title":"Creating a client service with MicroProfile RestClient"},{"location":"guided_exercises/03_rest_client_lab/#creating-a-client-service-with-microprofile-restclient","text":"","title":"Creating a client service with MicroProfile RestClient"},{"location":"guided_exercises/03_rest_client_lab/#introduction","text":"","title":"Introduction"},{"location":"guided_exercises/03_rest_client_lab/#what-you-will-learn","text":"Here are the main goals you will achieve with this hands-on execise: Learn the configuration required in a Helidon service to allow it to consume an external endpoints. With JAX-RS service, execute five different operations through an external service: List all Find by ID Insert Update Delete","title":"What you will learn"},{"location":"guided_exercises/03_rest_client_lab/#use-case","text":"For this scenario, you will use an existing JAX-RS service, the restaurant service . You will create a client application that can consume all the RESTful APIs available in the restaurant service . You will start with an existing service with a foundation that will support the development of your client application. Your task is to finish the service, as all the RestClient configuration and implementation is missing.Make sure your service can properly interact with the restaurant service .","title":"Use Case"},{"location":"guided_exercises/03_rest_client_lab/#pre-requisites","text":"To be able to go through this guided exercise, you will need to have the following components in your dev environment: Have finished the steps described in Preparing your environment","title":"Pre requisites"},{"location":"guided_exercises/03_rest_client_lab/#hands-on-practice","text":"For this scenario, you should create a client service that consumes an existing JAX-RS service: the restaurant service . You will enhance a partially written restaurant client service to allow it to integrate with the following restaurant service APIs: Method Path Description GET /restaurants Fetch all the items GET /restaurants/{id} Fetch an item by ID POST /restaurants Insert new items PUT /restaurants/{id} Update items DELETE /restaurants/{id} Delete items The client service is partially written and you are the one responsible for creating all the RestClient configuration and implementation that are missing. Your task is to finish this application and make sure you can interact with the restaurant service .","title":"Hands-on practice"},{"location":"guided_exercises/03_rest_client_lab/#understanding-the-services","text":"","title":"Understanding the services"},{"location":"guided_exercises/03_rest_client_lab/#the-restaurant-service","text":"The restaurant service provides RESTful APIs that allow managing the items that are currently needed by the restaurant. An item has the following structure: { \"name\" : \"water\" , \"description\" : \"Water appears as a clear, nontoxic liquid composed of hydrogen and oxygen, essential for life.\" , \"type\" : \"BEVERAGE\" , \"expires\" : \"2025-12-03\" , \"ingredients\" : [{ \"name\" : \"water\" , \"unit\" : \"L\" , \"quantity\" : 2 }] } Since our application needs to integrate with this service, after the implementation is finished, a practical test will require both services to be up running in our environment. In the restaurant service , check the class RestaurantController . These are the endpoints your client service should consume. Next, let's check the existing code for the client service and start coding.","title":"The restaurant service"},{"location":"guided_exercises/03_rest_client_lab/#the-restaurant-client-service","text":"Locate and open with your IDE of choice the project helidon-microstream-training-labs-foundation/restaurant-client-lab . Open the pom.xml and check your project has the following dependency: <dependency> <groupId> org.microprofile-ext.openapi-ext </groupId> <artifactId> openapi-ui </artifactId> <version> 1.1.5 </version> </dependency> This is the MP OpenAPI-UI extension . It will allow you to use your browser to interact with the REST APIs you are about to create. Once you are finished, you will see something like this: Let's get started with the integration of our restaurant client service and the restaurant service using MicroProfile RESTClient.","title":"The restaurant client service"},{"location":"guided_exercises/03_rest_client_lab/#integrating-through-microprofile-restclient","text":"In order to consume a service using RESTClient, we will: Create an interface that will match the service operations we want to be able to invoke; Set up the appropriate annotations to configure this interface as a rest client; Add to the application properties a reference to the external service that will be consumed by the rest client;","title":"Integrating through MicroProfile RESTClient"},{"location":"guided_exercises/03_rest_client_lab/#creating-the-restclient-interface","text":"Open the restaurant-client-lab in your IDE. Locate and open the RestaurantService interface. This is the interface we'll use as a RestClient to consume the external API exposed by Restaurant Controller part of the restaurant-service . Configure this interface as a RESTClient by adding, before the interface's name, the annotations @Path(\"restaurants\") and @RegisterRestClient . It will look like this: @Path ( \"restaurants\" ) @RegisterRestClient public interface RestaurantService { The next step is to create the contract of the methods you will consume on the external service. As a first example, let's check the insert operation. The RestaurantController (part of the restaurant-service ) , has the following method: @POST public Response insert ( @Valid Item item ) { return Response . status ( Response . Status . CREATED ) . entity ( repository . save ( item )) . build (); } In order to invoke the endpoint exposed by this method, create the following method declaration in your RestaurantService Interface : @POST public Response insert ( Item item ); Awesome! You've just created the first integration between your client and the external service! It's as easy as that! Now, implement the other four method declarations in the RestaurantService interface. Make sure you have all five methods of the external service: findById , insert , update , delete and getAll .","title":"Creating the RESTClient interface"},{"location":"guided_exercises/03_rest_client_lab/#configuring-the-restaurantservice-endpoint","text":"The next step is to create a MicroProfile configuration property, where the property's name is the RESTClient interface FQDN, and the value is the external service URL. Add the following property in resources/META-INF/microprofile-config.properties : org.a4j.restaurant.client.RestaurantService/mp-rest/url = http://localhost:8080/ Good job The client configuration is now done. You've learned that when using RESTClient, the integration is done with really few code. The contract goes within the interface and all configuration within the microprofile-config.properties file.","title":"Configuring the RestaurantService endpoint"},{"location":"guided_exercises/03_rest_client_lab/#testing-the-service","text":"To test this service you need to run two applications, the restaurant-service and the restaurant-client-service . Each service will run in a different port.","title":"Testing the service"},{"location":"guided_exercises/03_rest_client_lab/#starting-the-restaurant-service","text":"To start the restaurant service locally, follow these steps: Open the terminal; Access the foundation project directory, e.g.: cd $YOUR_CUSTOM_DIR /helidon-microstream-training-labs-foundation/restaurant Package and run the service: mvn clean package java -jar target/restaurant.jar Use your browser to confirm the service is up and running at: Restaurant service: http://localhost:8080/ About the restaurant service persistence For this lab's learning purpose a database persistence is not required. The service uses an in-memory list to store and retrieve data. To simplify the lab it is also initialized with two items in the list : \"Water\" and \"Juice\". Now, let's package and run our client.","title":"Starting the restaurant service"},{"location":"guided_exercises/03_rest_client_lab/#starting-the-restaurant-client-service","text":"On a different terminal tab, access the service directory. e.g. cd $YOUR_CUSTOM_DIR /helidon-microstream-training-labs-foundation/restaurant-client-lab Package and run the service: mvn clean package pom.xml java -jar target/restaurant-client-lab.jar Use your browser to confirm the service is up and running at Restaurant client service: http://localhost:8081/","title":"Starting the restaurant client service"},{"location":"guided_exercises/03_rest_client_lab/#testing-the-restaurant-client-service","text":"Your client includes the microprofile extension ui for OpenAPI. To access the ui, open: Client OpenAPI UI: http://localhost:8081/openapi-ui . Select the GET /items endpoint, click on \" try it out \" button, and then on the \" Execute \" blue button. You should get an HTTP 200 response and a list with two items. Now, use your client service API to delete the \" juice \" item. In your browser, locate the DELETE items endpoint and click on \"Try it out\" . Type juice in the Id field and click on the Execute button. Finally, confirm that the item was deleted and is not retrieved with the GET items endpoint endpoint. The response should be an HTTP 200 and juice should not be in the list. [ { \"description\" : \"Water appears as a clear, nontoxic liquid composed of hydrogen and oxygen, essential for life\" , \"expires\" : \"2025-05-29\" , \"ingredients\" : [ { \"name\" : \"water\" , \"quantity\" : 2 , \"unit\" : \"L\" } ], \"name\" : \"water\" , \"type\" : \"BEVERAGE\" } ] Feel free to use the OpenAPI UI, postman or cURL to test all your service's endpoints. Congratulations Congratulations, you've implemented a client service application with Helidon and Microprofile that can consume an external JAX-RS service by using the new RESTClient MicroProfile!","title":"Testing the restaurant client service"},{"location":"guided_exercises/challenges/04_challenge_rest/","text":"Golden service apis for ACME Store In this exercise you can validate and practice your knowledge of the following concepts: Java microservice implementation with Helidon; API designing to meet specific criteria; RESTful services implementation with JAX-RS; Extense API documentation with OpenAPI; In-memory persistence with MicroStream; Validation with Bean Validation; Implicit and constant usage of CDI; Getting familiar with the use case and the exercise goals described next is highly recommended, as a detailed step-by-step guide is not provided. Friendly advice : consider leveraging this opportunity to upskill by making the best use of your knowledge and research skills to code the solution without replicating the provided solution. Scenario Your consultancy was requested by the Acme Store company. The company's technical team wants to learn good practices and recommendations for Java microservices built on top of the building blocks offered by specifications. They demonstrate interest in validating the experience of delivering Microprofile on top of the Helidon runtime. Your task is to provide a Java backend service, with Helidon, to handle the basic operations of the store's products . Goals See below the solution's pre-requisites. ( Easily track your progress by marking tasks as \"done\". ) The service should be named acme-store-rest . It must rely on Microprofile 3.3 and Helidon . The service handles operations for Products maintenance. A Product should have: An ID, which is the name : mandatory and should be at max 100 chars. A description : mandatory, should have at least 5 chars A quantity : mandatory and should be higher than 0. The following operations for a Product should be available: List all the products Insert a new product Retrieve a product by ID Update a product based on its ID Delete a product using its ID It should be a RESTful application. The urls should follow these rules: To list all products: GET \"/products\" To insert a product: POST \"/products\" To find a product by ID: GET \"/products/{productName}\" To delete a product: DELETE \"/products/{productName}\" To update a product: PUT \"/products/{productName}\" The APIs should be properly documented: All APIs should have documentation for the Operation , including summary and description ; The responses ( APIResponse ) should be documented according to potential results, with proper description for returned HTTP codes ( responseCode , e.g. 200, 404). The APIs should include information about release and stability through tags: The following apis are part of the first release, and tagged ( @Tag ) as 1.0 : List all Find by ID Save new product These APIs are still in BETA phase, and are tagged ( @Tag ) as BETA : Update Delete Expected results The solution should look like this: Hands-on guidance To save your time, the customer's team has created a basic project using the microprofile starter . They have provided domain related objects and boilerplate code. If you prefer, you can also start a project from scratch and use the quickstart project in case you need to check dependencies configuration and such. The quickstart project: acme-store-rest Get started by cloning the project to your machine (if you haven't already). git clone https://github.com/architects4j/helidon-microstream-training-labs-foundation cd acme-store-rest Open the project in your IDE of choice and give it an overall look. You can find multiple comments pointing to code that needs adjustment. If you are feeling confident, go ahead and get started with the requirements implementation. For general guidance, follow the next sections. Persistence The quickstart project is built on top of a ultra-fast in-memory persistence with MicroStream . Learn more about this persistence option by checking the implementation of the org.a4j.product.Inventory class, enabled by the dependency one.microstream:microstream-integrations-cdi: . Implementing the solution REST Endpoints The product's endpoints are partially implementated in the class ProductResource . Use a ProductResource to implement your REST APIs: Scope: An appropriate CDI scope should be set for this bean. The @RequestScope should be enough. Path : Remember to set the javax.ws.rs.@Path according to the goals of the project; HTTP Methods : To differentiate APIs and map incoming requests to http methods, annotate the methods with: @DELETE , @PUT , @POST and @GET from javax.ws.rs . Custom paths : To create an endpoint like /products/{id} , you can annotate a method with @Path(\"{id}\") and add @pathParam to the parameter. Example: public Product findById ( @PathParam ( \"id\" ) String id ) {} Exception Handling : Avoid errors in case an invalid data is sent to your endpoints. WebApplicationException can be used for this purpose. Example: repository . findById ( id ). orElseThrow (() -> new WebApplicationException ( \"There is no product with the id \" + id , Response . Status . NOT_FOUND )); Responses with HTTP codes that make sense : Response.Status provides a list of possibilities. Example: return Response . status ( Response . Status . CREATED ) . entity ( repository . save ( product )) . build (); Field validation To implement the business rules related to the product attributes, you can use Bean Validation annotations on your Product.java . The following dependency was already added to the project's pom.xml <dependency> <groupId> org.glassfish.jersey.ext </groupId> <artifactId> jersey-bean-validation </artifactId> </dependency> In the class Product.java , use the multiple javax.validation.constraints options (like @NotBlank , @NotNull , @Size ). Configure each attribute's contraints accordingly along with the error message you want to associate with it. Example: @NotBlank @Size ( min = 3 , max = 100 , message = \"The name size should be between 3 and 100 chars\" ) private final String name ; In the ProductResource.java class, identify the methods where validation is needed, and use the @Valid annotation for the parameters. Example: public Product update ( @PathParam ( \"id\" ) String id , @Valid Product product ) { APIs documentation with OpenAPI Schema The schema configuration can be done through annotations in the data objects, like Product . Notice the class schema is already configured. No extra changes are needed here: @Schema ( name = \"Product\" , description = \"The entity that represents a product of acme store\" ) public class Product { Configure the @Schema for all the attributes. Don't forget to add an example attribute. Later on, we will use these configured schemas on the ProductResource OpenAPI configurations. The endpoints Configure the @Tag for each method as specified in the exercise goals. Example: @Tag ( name = \"BETA\" , description = \"APIs currently in beta state\" ) For each method, configure the @Operation details with a summary and description ; For each method, specify possible responses with @APIResponse , setting the responseCode and the description that explains what this response means. Example: @APIResponse ( responseCode = \"200\" , description = \"Product successfully found\" ) Some @APIResponse might require extra information about the content being returned. This is where you can use the schema we configured previously in the Product class. Example of an APIResponse for the findById operation: @APIResponse ( description = \"The product\" , content = @Content ( mediaType = MediaType . APPLICATION_JSON , schema = @Schema ( implementation = Product . class ) ) ) Input parameters may also require API documentation. For example, when saving a product, we can inform the user what is the expected input data by using the @RequestBody annotation, and the attributes description and content . The content attribute points to our product schema. See an example below: public Response insert ( @RequestBody ( description = \"The product\" , content = @Content ( mediaType = \"application/json\" , schema = @Schema ( implementation = Product . class ))) @Valid Product product ) { Running your application To test your application, you can package it with Maven, run with Java, and use the OpenAPI UI, Postman, curl, or other tool of preference to invoke the rest APIs. To package and run your application without Helidon CLI: mvn clean package java -jar target/acme-store-rest.jar or, using Helidon CLI: helidon build helidon dev By default it will run on port 8081, as configured in the microprofile-config.properties . Validate your APIs documentation with OpenAPI UI at: http://localhost:8081/openapi-ui/ Check the service implementation with the following request examples: Insert a new product curl --location --request POST 'http://localhost:8081/products' \\ --header 'Content-Type: application/json' \\ --data-raw '{\"name\": \"bottle\", \"description\": \"Can store cold and hot liquids.\", \"quantity\": \"2\"}' List all products curl --location --request GET 'http://localhost:8081/products' Search a product by ID (name) curl --location --request GET 'http://localhost:8081/products/bottle' Update a product using its ID (name) curl --location --request POST 'http://localhost:8081/products/bottle' \\ --header 'Content-Type: application/json' \\ --data-raw '{\"name\": \"bottle\", \"description\": \"Can store ONLY cold liquids.\", \"quantity\": \"2\"}' Delete a product by ID (name) curl --location --request DELETE 'http://localhost:8081/products/bottle' The next step is to try data that actually breaks the business rules and validate if your application is validating for example, the required fields. If you can successfully execute the above items, it means you acomplished all this challenge goals! Congratulations! You've finished your task for Acme Store with great success! You have created an examplar backend service that be used as a model, with good examples of usage of RESTFul concepts, beans validation, well-documented APIs, and much more! We're looking forward to seeing you upskilling by working on upcoming challenges!","title":"Golden service apis for ACME Store"},{"location":"guided_exercises/challenges/04_challenge_rest/#golden-service-apis-for-acme-store","text":"In this exercise you can validate and practice your knowledge of the following concepts: Java microservice implementation with Helidon; API designing to meet specific criteria; RESTful services implementation with JAX-RS; Extense API documentation with OpenAPI; In-memory persistence with MicroStream; Validation with Bean Validation; Implicit and constant usage of CDI; Getting familiar with the use case and the exercise goals described next is highly recommended, as a detailed step-by-step guide is not provided. Friendly advice : consider leveraging this opportunity to upskill by making the best use of your knowledge and research skills to code the solution without replicating the provided solution.","title":"Golden service apis for ACME Store"},{"location":"guided_exercises/challenges/04_challenge_rest/#scenario","text":"Your consultancy was requested by the Acme Store company. The company's technical team wants to learn good practices and recommendations for Java microservices built on top of the building blocks offered by specifications. They demonstrate interest in validating the experience of delivering Microprofile on top of the Helidon runtime. Your task is to provide a Java backend service, with Helidon, to handle the basic operations of the store's products .","title":"Scenario"},{"location":"guided_exercises/challenges/04_challenge_rest/#goals","text":"See below the solution's pre-requisites. ( Easily track your progress by marking tasks as \"done\". ) The service should be named acme-store-rest . It must rely on Microprofile 3.3 and Helidon . The service handles operations for Products maintenance. A Product should have: An ID, which is the name : mandatory and should be at max 100 chars. A description : mandatory, should have at least 5 chars A quantity : mandatory and should be higher than 0. The following operations for a Product should be available: List all the products Insert a new product Retrieve a product by ID Update a product based on its ID Delete a product using its ID It should be a RESTful application. The urls should follow these rules: To list all products: GET \"/products\" To insert a product: POST \"/products\" To find a product by ID: GET \"/products/{productName}\" To delete a product: DELETE \"/products/{productName}\" To update a product: PUT \"/products/{productName}\" The APIs should be properly documented: All APIs should have documentation for the Operation , including summary and description ; The responses ( APIResponse ) should be documented according to potential results, with proper description for returned HTTP codes ( responseCode , e.g. 200, 404). The APIs should include information about release and stability through tags: The following apis are part of the first release, and tagged ( @Tag ) as 1.0 : List all Find by ID Save new product These APIs are still in BETA phase, and are tagged ( @Tag ) as BETA : Update Delete","title":"Goals"},{"location":"guided_exercises/challenges/04_challenge_rest/#expected-results","text":"The solution should look like this:","title":"Expected results"},{"location":"guided_exercises/challenges/04_challenge_rest/#hands-on-guidance","text":"To save your time, the customer's team has created a basic project using the microprofile starter . They have provided domain related objects and boilerplate code. If you prefer, you can also start a project from scratch and use the quickstart project in case you need to check dependencies configuration and such.","title":"Hands-on guidance"},{"location":"guided_exercises/challenges/04_challenge_rest/#the-quickstart-project-acme-store-rest","text":"Get started by cloning the project to your machine (if you haven't already). git clone https://github.com/architects4j/helidon-microstream-training-labs-foundation cd acme-store-rest Open the project in your IDE of choice and give it an overall look. You can find multiple comments pointing to code that needs adjustment. If you are feeling confident, go ahead and get started with the requirements implementation. For general guidance, follow the next sections. Persistence The quickstart project is built on top of a ultra-fast in-memory persistence with MicroStream . Learn more about this persistence option by checking the implementation of the org.a4j.product.Inventory class, enabled by the dependency one.microstream:microstream-integrations-cdi: .","title":"The quickstart project: acme-store-rest"},{"location":"guided_exercises/challenges/04_challenge_rest/#implementing-the-solution","text":"","title":"Implementing the solution"},{"location":"guided_exercises/challenges/04_challenge_rest/#rest-endpoints","text":"The product's endpoints are partially implementated in the class ProductResource . Use a ProductResource to implement your REST APIs: Scope: An appropriate CDI scope should be set for this bean. The @RequestScope should be enough. Path : Remember to set the javax.ws.rs.@Path according to the goals of the project; HTTP Methods : To differentiate APIs and map incoming requests to http methods, annotate the methods with: @DELETE , @PUT , @POST and @GET from javax.ws.rs . Custom paths : To create an endpoint like /products/{id} , you can annotate a method with @Path(\"{id}\") and add @pathParam to the parameter. Example: public Product findById ( @PathParam ( \"id\" ) String id ) {} Exception Handling : Avoid errors in case an invalid data is sent to your endpoints. WebApplicationException can be used for this purpose. Example: repository . findById ( id ). orElseThrow (() -> new WebApplicationException ( \"There is no product with the id \" + id , Response . Status . NOT_FOUND )); Responses with HTTP codes that make sense : Response.Status provides a list of possibilities. Example: return Response . status ( Response . Status . CREATED ) . entity ( repository . save ( product )) . build ();","title":"REST Endpoints"},{"location":"guided_exercises/challenges/04_challenge_rest/#field-validation","text":"To implement the business rules related to the product attributes, you can use Bean Validation annotations on your Product.java . The following dependency was already added to the project's pom.xml <dependency> <groupId> org.glassfish.jersey.ext </groupId> <artifactId> jersey-bean-validation </artifactId> </dependency> In the class Product.java , use the multiple javax.validation.constraints options (like @NotBlank , @NotNull , @Size ). Configure each attribute's contraints accordingly along with the error message you want to associate with it. Example: @NotBlank @Size ( min = 3 , max = 100 , message = \"The name size should be between 3 and 100 chars\" ) private final String name ; In the ProductResource.java class, identify the methods where validation is needed, and use the @Valid annotation for the parameters. Example: public Product update ( @PathParam ( \"id\" ) String id , @Valid Product product ) {","title":"Field validation"},{"location":"guided_exercises/challenges/04_challenge_rest/#apis-documentation-with-openapi","text":"","title":"APIs documentation with OpenAPI"},{"location":"guided_exercises/challenges/04_challenge_rest/#schema","text":"The schema configuration can be done through annotations in the data objects, like Product . Notice the class schema is already configured. No extra changes are needed here: @Schema ( name = \"Product\" , description = \"The entity that represents a product of acme store\" ) public class Product { Configure the @Schema for all the attributes. Don't forget to add an example attribute. Later on, we will use these configured schemas on the ProductResource OpenAPI configurations.","title":"Schema"},{"location":"guided_exercises/challenges/04_challenge_rest/#the-endpoints","text":"Configure the @Tag for each method as specified in the exercise goals. Example: @Tag ( name = \"BETA\" , description = \"APIs currently in beta state\" ) For each method, configure the @Operation details with a summary and description ; For each method, specify possible responses with @APIResponse , setting the responseCode and the description that explains what this response means. Example: @APIResponse ( responseCode = \"200\" , description = \"Product successfully found\" ) Some @APIResponse might require extra information about the content being returned. This is where you can use the schema we configured previously in the Product class. Example of an APIResponse for the findById operation: @APIResponse ( description = \"The product\" , content = @Content ( mediaType = MediaType . APPLICATION_JSON , schema = @Schema ( implementation = Product . class ) ) ) Input parameters may also require API documentation. For example, when saving a product, we can inform the user what is the expected input data by using the @RequestBody annotation, and the attributes description and content . The content attribute points to our product schema. See an example below: public Response insert ( @RequestBody ( description = \"The product\" , content = @Content ( mediaType = \"application/json\" , schema = @Schema ( implementation = Product . class ))) @Valid Product product ) {","title":"The endpoints"},{"location":"guided_exercises/challenges/04_challenge_rest/#running-your-application","text":"To test your application, you can package it with Maven, run with Java, and use the OpenAPI UI, Postman, curl, or other tool of preference to invoke the rest APIs. To package and run your application without Helidon CLI: mvn clean package java -jar target/acme-store-rest.jar or, using Helidon CLI: helidon build helidon dev By default it will run on port 8081, as configured in the microprofile-config.properties . Validate your APIs documentation with OpenAPI UI at: http://localhost:8081/openapi-ui/ Check the service implementation with the following request examples: Insert a new product curl --location --request POST 'http://localhost:8081/products' \\ --header 'Content-Type: application/json' \\ --data-raw '{\"name\": \"bottle\", \"description\": \"Can store cold and hot liquids.\", \"quantity\": \"2\"}' List all products curl --location --request GET 'http://localhost:8081/products' Search a product by ID (name) curl --location --request GET 'http://localhost:8081/products/bottle' Update a product using its ID (name) curl --location --request POST 'http://localhost:8081/products/bottle' \\ --header 'Content-Type: application/json' \\ --data-raw '{\"name\": \"bottle\", \"description\": \"Can store ONLY cold liquids.\", \"quantity\": \"2\"}' Delete a product by ID (name) curl --location --request DELETE 'http://localhost:8081/products/bottle' The next step is to try data that actually breaks the business rules and validate if your application is validating for example, the required fields. If you can successfully execute the above items, it means you acomplished all this challenge goals! Congratulations! You've finished your task for Acme Store with great success! You have created an examplar backend service that be used as a model, with good examples of usage of RESTFul concepts, beans validation, well-documented APIs, and much more! We're looking forward to seeing you upskilling by working on upcoming challenges!","title":"Running your application"},{"location":"guided_exercises/challenges/05_challenge_nosql/","text":"NoSQL persistence on Java services In this exercise you can validate and practice your knowledge of the following concepts: Java microservice implementation with Helidon; Dev experience when using NoSQL databases with Java; Jakarta NoSQL; Implicit and constant usage of CDI; Getting familiar with the use case and the exercise goals described next is highly recommended, as a detailed step-by-step guide is not provided. Friendly advice : consider leveraging this opportunity to upskill by making the best use of your knowledge and research skills to code the solution without replicating the provided solution. Scenario Acme Store contacted you to ask for advise about NoSQL databases usage in MicroProfile-based services. They need a solution built on top of the RESTFul service delivered on the previous exercise. If you used the quickstart, by now you should have a microservice that relies on in-memory persistence with MicroStream. We will now add another option of persistence layer to this service, allowing it to persist data on MongoDB . Goals About the service: You should adapt an existing application, the acme-store-rest application. It uses Microprofile 3.3 + Helidon and MicroStream for persistence. The service handles Product , and provides RESTFul operations for it: List all products: GET \"/products/\" Find a product by ID: GET \"/products/{productName}\" Delete a product: DELETE \"/products/{productName}\" Update a product: PUT \"/products/{productName}\" Insert a product: POST \"/products/{productName}\" The APIs are documented with the Eclipse Microprofile-Open-API ; It's persistence layer relies on MicroStream for performant in-memory persistence capabilities. Goals: Add the support for persistence with JNoSQL for MongoDB; Change as minimum code as possible; Test the application; How to get started The database This exercise requires a MongoDB instance. To facilitate you can use Docker. If you don't have Docker installer yet, you can get it at: https://www.docker.com/ Running MongoDB with Docker: docker run -d --name mongodb-instance -p 27017 :27017 mongo The project You can use the delivered service you finished on the lab Golden APIs for ACME Store . If you prefer, you can also start from this quickstart application. It's similar to a resulting application from the previous lab with extra instructions on what the required tasks: https://github.com/architects4j/helidon-microstream-training-labs-foundation/tree/main/acme-store-rest-nosql To start the application, you can build, package and run it as usual. Implementing the solution See below a general guidance on how you can add NoSQL persistence to this service: Dependencies : Add the Jakarta NoSQL dependencies to pom.xml : <dependency> <groupId> org.eclipse.jnosql.mapping </groupId> <artifactId> mapping-document </artifactId> <version> 1.0.0-b4 </version> </dependency> <dependency> <groupId> org.eclipse.jnosql.communication </groupId> <artifactId> mongodb-driver </artifactId> <version> 1.0.0-b4 </version> </dependency> Database configurations : Add the MongoDB configurations to microprofile-config.properties : # MongoDB Configs document = document document.database = restaurant document.settings.jakarta.nosql.host = localhost:27017 document.provider = org.eclipse.jnosql.communication.mongodb.document.MongoDBDocumentConfiguration Entity configurations : Configure the Product as an entity bean: Add the @jakarta.nosql.mapping.Entity declaration; Add an empty constructor method; g3. Annotate the attributes with adequate column configurations. Use @Id and @Column . Remember, the attributes can no longer be final. The document manager bean: In the package org.a4j.product.infra create a new class DocumentManagerProducer : package org.a4j.product.infra ; //TODO: Set this bean as ApplicationScope class DocumentManagerProducer { //TODO: Use CDI to inject this bean //TODO: Obtain the `document` value configured in microprofile-config.properties. Use @ConfigProperty. private DocumentCollectionManager manager ; // TODO: Configure as a producer with @Produces public DocumentCollectionManager getManager () { return manager ; } public void destroy ( @Disposes DocumentCollectionManager manager ) { manager . close (); } } Creating a new repository : Add a new ProductRepository interface. It should extend the Repository interface: extends Repository < Product , String > Adjusting the resource class implementation : In the ProductResource , let's change the persistence layer. Replace the existing repository based on Inventory with our new one ProductResource . //**Before:** private Inventory repository ; //**After:** @Inject private ProductRepository repository ; the following injection method as we're already injecting in the attribute level: @Inject ProductResource ( Inventory repository ) { this . repository = repository ; } Adding a new method to the repository: : At this point, you will notice the code doesn't compile since the method findAll does not exist in the repository. Currently, (v1.0.0-b4) the jakarta. nosql.mapping.Repository does not offer a findAll out-of-the-box. It does offer save , deleteById , findById , existsById and count , therefore, the only method you need to att to the ProductRepository interface to deliver the existing endpoints is the getAll method. In the ProductRepository , add the method signature. Example: List < Product > findAll (); Testing the service By default it will run on port 8081, as configured in the microprofile-config.properties . Validate your APIs documentation with OpenAPI UI at: http://localhost:8081/openapi-ui/ Check the service implementation with the following request examples: Insert a new product curl --location --request POST 'http://localhost:8081/products' \\ --header 'Content-Type: application/json' \\ --data-raw '{\"name\": \"bottle\", \"description\": \"Can store cold and hot liquids.\", \"quantity\": \"2\"}' List all products curl --location --request GET 'http://localhost:8081/products' Search a product by ID (name) curl --location --request GET 'http://localhost:8081/products/bottle' Update a product using its ID (name) curl --location --request POST 'http://localhost:8081/products/bottle' \\ --header 'Content-Type: application/json' \\ --data-raw '{\"name\": \"bottle\", \"description\": \"Can store ONLY cold liquids.\", \"quantity\": \"2\"}' Delete a product by ID (name) curl --location --request DELETE 'http://localhost:8081/products/bottle' If you can successfully execute the above items, it means you acomplished all this challenge goals! Congratulations! You've finished your task for Acme Store! You have easily modified an existing project by taking advantadge of a well-defined persistence layer. You have used JNoSQL to allow this service to persist its data using MongoDB. Well done!","title":"NoSQL persistence on Java services"},{"location":"guided_exercises/challenges/05_challenge_nosql/#nosql-persistence-on-java-services","text":"In this exercise you can validate and practice your knowledge of the following concepts: Java microservice implementation with Helidon; Dev experience when using NoSQL databases with Java; Jakarta NoSQL; Implicit and constant usage of CDI; Getting familiar with the use case and the exercise goals described next is highly recommended, as a detailed step-by-step guide is not provided. Friendly advice : consider leveraging this opportunity to upskill by making the best use of your knowledge and research skills to code the solution without replicating the provided solution.","title":"NoSQL persistence on Java services"},{"location":"guided_exercises/challenges/05_challenge_nosql/#scenario","text":"Acme Store contacted you to ask for advise about NoSQL databases usage in MicroProfile-based services. They need a solution built on top of the RESTFul service delivered on the previous exercise. If you used the quickstart, by now you should have a microservice that relies on in-memory persistence with MicroStream. We will now add another option of persistence layer to this service, allowing it to persist data on MongoDB .","title":"Scenario"},{"location":"guided_exercises/challenges/05_challenge_nosql/#goals","text":"About the service: You should adapt an existing application, the acme-store-rest application. It uses Microprofile 3.3 + Helidon and MicroStream for persistence. The service handles Product , and provides RESTFul operations for it: List all products: GET \"/products/\" Find a product by ID: GET \"/products/{productName}\" Delete a product: DELETE \"/products/{productName}\" Update a product: PUT \"/products/{productName}\" Insert a product: POST \"/products/{productName}\" The APIs are documented with the Eclipse Microprofile-Open-API ; It's persistence layer relies on MicroStream for performant in-memory persistence capabilities. Goals: Add the support for persistence with JNoSQL for MongoDB; Change as minimum code as possible; Test the application;","title":"Goals"},{"location":"guided_exercises/challenges/05_challenge_nosql/#how-to-get-started","text":"","title":"How to get started"},{"location":"guided_exercises/challenges/05_challenge_nosql/#the-database","text":"This exercise requires a MongoDB instance. To facilitate you can use Docker. If you don't have Docker installer yet, you can get it at: https://www.docker.com/ Running MongoDB with Docker: docker run -d --name mongodb-instance -p 27017 :27017 mongo","title":"The database"},{"location":"guided_exercises/challenges/05_challenge_nosql/#the-project","text":"You can use the delivered service you finished on the lab Golden APIs for ACME Store . If you prefer, you can also start from this quickstart application. It's similar to a resulting application from the previous lab with extra instructions on what the required tasks: https://github.com/architects4j/helidon-microstream-training-labs-foundation/tree/main/acme-store-rest-nosql To start the application, you can build, package and run it as usual.","title":"The project"},{"location":"guided_exercises/challenges/05_challenge_nosql/#implementing-the-solution","text":"See below a general guidance on how you can add NoSQL persistence to this service: Dependencies : Add the Jakarta NoSQL dependencies to pom.xml : <dependency> <groupId> org.eclipse.jnosql.mapping </groupId> <artifactId> mapping-document </artifactId> <version> 1.0.0-b4 </version> </dependency> <dependency> <groupId> org.eclipse.jnosql.communication </groupId> <artifactId> mongodb-driver </artifactId> <version> 1.0.0-b4 </version> </dependency> Database configurations : Add the MongoDB configurations to microprofile-config.properties : # MongoDB Configs document = document document.database = restaurant document.settings.jakarta.nosql.host = localhost:27017 document.provider = org.eclipse.jnosql.communication.mongodb.document.MongoDBDocumentConfiguration Entity configurations : Configure the Product as an entity bean: Add the @jakarta.nosql.mapping.Entity declaration; Add an empty constructor method; g3. Annotate the attributes with adequate column configurations. Use @Id and @Column . Remember, the attributes can no longer be final. The document manager bean: In the package org.a4j.product.infra create a new class DocumentManagerProducer : package org.a4j.product.infra ; //TODO: Set this bean as ApplicationScope class DocumentManagerProducer { //TODO: Use CDI to inject this bean //TODO: Obtain the `document` value configured in microprofile-config.properties. Use @ConfigProperty. private DocumentCollectionManager manager ; // TODO: Configure as a producer with @Produces public DocumentCollectionManager getManager () { return manager ; } public void destroy ( @Disposes DocumentCollectionManager manager ) { manager . close (); } } Creating a new repository : Add a new ProductRepository interface. It should extend the Repository interface: extends Repository < Product , String > Adjusting the resource class implementation : In the ProductResource , let's change the persistence layer. Replace the existing repository based on Inventory with our new one ProductResource . //**Before:** private Inventory repository ; //**After:** @Inject private ProductRepository repository ; the following injection method as we're already injecting in the attribute level: @Inject ProductResource ( Inventory repository ) { this . repository = repository ; } Adding a new method to the repository: : At this point, you will notice the code doesn't compile since the method findAll does not exist in the repository. Currently, (v1.0.0-b4) the jakarta. nosql.mapping.Repository does not offer a findAll out-of-the-box. It does offer save , deleteById , findById , existsById and count , therefore, the only method you need to att to the ProductRepository interface to deliver the existing endpoints is the getAll method. In the ProductRepository , add the method signature. Example: List < Product > findAll ();","title":"Implementing the solution"},{"location":"guided_exercises/challenges/05_challenge_nosql/#testing-the-service","text":"By default it will run on port 8081, as configured in the microprofile-config.properties . Validate your APIs documentation with OpenAPI UI at: http://localhost:8081/openapi-ui/ Check the service implementation with the following request examples: Insert a new product curl --location --request POST 'http://localhost:8081/products' \\ --header 'Content-Type: application/json' \\ --data-raw '{\"name\": \"bottle\", \"description\": \"Can store cold and hot liquids.\", \"quantity\": \"2\"}' List all products curl --location --request GET 'http://localhost:8081/products' Search a product by ID (name) curl --location --request GET 'http://localhost:8081/products/bottle' Update a product using its ID (name) curl --location --request POST 'http://localhost:8081/products/bottle' \\ --header 'Content-Type: application/json' \\ --data-raw '{\"name\": \"bottle\", \"description\": \"Can store ONLY cold liquids.\", \"quantity\": \"2\"}' Delete a product by ID (name) curl --location --request DELETE 'http://localhost:8081/products/bottle' If you can successfully execute the above items, it means you acomplished all this challenge goals! Congratulations! You've finished your task for Acme Store! You have easily modified an existing project by taking advantadge of a well-defined persistence layer. You have used JNoSQL to allow this service to persist its data using MongoDB. Well done!","title":"Testing the service"},{"location":"more/architects4j/","text":"Architects4J We are tech experts who believe open source and collaborative communities are the way to go. We'll be happy to connect with you through our social media, let's connect! Karina Varela Otavio Santana","title":"Architects4J"},{"location":"more/architects4j/#architects4j","text":"We are tech experts who believe open source and collaborative communities are the way to go. We'll be happy to connect with you through our social media, let's connect! Karina Varela Otavio Santana","title":"Architects4J"},{"location":"more/sample_projects/","text":"","title":"Sample projects"},{"location":"more/training/","text":"Instructor-lead trainings In this course, you will learn the fundamentals of how to develop modern cloud-native microservices with Helidon, Microstream and MicroProfile. MicroProfile is a specification for building microservices architecture. MicroProfile was derived from Jakarta EE, formerly Java EE, and thus allows developers to migrate and reuse their existing Java EE code seamlessly in modern microservice applications. It delivers application portability of microservices across multiple MicroProfile vendor frameworks such as Helidon, Helidon, Quarkus, Open Liberty, and TomEE. Get Helidon Micro: https://helidon.io/ Who should attend Developers, software architects, and project managers who want to develop modern cloud-native microservices with Helidon Micro. Also trainers and consultants. Java developers Software architects Project managers Java trainers Technical consultants and sales engineers Prerequisites Proficiency in using a Java IDE such as Eclipse, IntelliJ, or Netbeans Fundamental knowledge in Java Proficiency in object-oriented programming Experience with Maven Experience with Git Course Objectives By the end of the course, you should be able to meet the following objectives: Design of a cloud-native microservice architecture Build microservices with MicroProfile and Helidon Build independent REST services Persist data by using Java Persistence API and MicroStream Secure your microservices Test and check your microservices Build and deploy your microservices Course Content Cloud-native microservice architecture MicroProfile introduction and overview Getting started with Helidon Injecting dependencies into microservices with Contexts and Dependency Injection Create a RESTful web service Create a REST service with JAX-RS and JSON-B Use REST client Consume a RESTful web service with JSON-B and JSON-P Document and filter RESTful APIs by using OpenAPI REactive service: Consume RESTful web services asynchronously Configuration Static configuration injection using MicroProfile Config Fault tolerance Observability MicroProfile Metrics by using Jaeger and MicroProfile OpenTracing MicroProfile Health Check Security Authentication and authorization Control user and role access by using MicroProfile JSON Web Tokens (JWT) Validate user input by using bean validation Persistence Caching HTTP session data by using JCache and MicroStream Persist data by using MicroStream native object graph persistence Testing microservices Build and deployment of microservices Exercises with coding Answering your individual questions","title":"Training"},{"location":"more/training/#who-should-attend","text":"Developers, software architects, and project managers who want to develop modern cloud-native microservices with Helidon Micro. Also trainers and consultants. Java developers Software architects Project managers Java trainers Technical consultants and sales engineers","title":"Who should attend"},{"location":"more/training/#prerequisites","text":"Proficiency in using a Java IDE such as Eclipse, IntelliJ, or Netbeans Fundamental knowledge in Java Proficiency in object-oriented programming Experience with Maven Experience with Git","title":"Prerequisites"},{"location":"more/training/#course-objectives","text":"By the end of the course, you should be able to meet the following objectives: Design of a cloud-native microservice architecture Build microservices with MicroProfile and Helidon Build independent REST services Persist data by using Java Persistence API and MicroStream Secure your microservices Test and check your microservices Build and deploy your microservices","title":"Course Objectives"},{"location":"more/training/#course-content","text":"Cloud-native microservice architecture MicroProfile introduction and overview Getting started with Helidon Injecting dependencies into microservices with Contexts and Dependency Injection Create a RESTful web service Create a REST service with JAX-RS and JSON-B Use REST client Consume a RESTful web service with JSON-B and JSON-P Document and filter RESTful APIs by using OpenAPI REactive service: Consume RESTful web services asynchronously Configuration Static configuration injection using MicroProfile Config Fault tolerance Observability MicroProfile Metrics by using Jaeger and MicroProfile OpenTracing MicroProfile Health Check Security Authentication and authorization Control user and role access by using MicroProfile JSON Web Tokens (JWT) Validate user input by using bean validation Persistence Caching HTTP session data by using JCache and MicroStream Persist data by using MicroStream native object graph persistence Testing microservices Build and deployment of microservices Exercises with coding Answering your individual questions","title":"Course Content"}]}